# PureBasic Debug Adapter (DAP) Technical Documentation

> This document describes the technical principles and implementation details of the debug adapter in the vscode-purebasic extension.
> Protocol analysis source: [fantaisie-software/purebasic](https://github.com/fantaisie-software/purebasic) open-source IDE code.

---

## Table of Contents

1. [Technical Principles: PureBasic Debug Protocol](#1-technical-principles-purebasic-debug-protocol)
2. [Architecture Design](#2-architecture-design)
3. [File Structure](#3-file-structure)
4. [Configuration Guide](#4-configuration-guide)
5. [Key Implementation Points](#5-key-implementation-points)
6. [Risks and Challenges](#6-risks-and-challenges)

---

## 1. Technical Principles: PureBasic Debug Protocol

### 1.1 Transport Layer

The PureBasic debug system supports multiple transport methods, using **two unidirectional channels** for bidirectional communication:

#### Windows Named Pipe

```
PipeA: \\.\pipe\PureBasic_DebuggerPipeA_XXXXXXXX  (Debugger → Debuggee)
PipeB: \\.\pipe\PureBasic_DebuggerPipeB_XXXXXXXX  (Debuggee → Debugger)
```

- `XXXXXXXX` is an 8-digit hexadecimal random ID generated by the debugger at startup
- The pipe ID is injected into the debuggee process via environment variable `PB_DEBUGGER_Communication` (format: `XXXXXXXX`)

#### Unix FIFO (macOS/Linux)

```
PipeA: /tmp/PureBasic_DebuggerPipeA_XXXXXXXX
PipeB: /tmp/PureBasic_DebuggerPipeB_XXXXXXXX
```

- Uses FIFO special files (named pipes) for inter-process communication
- Must strictly follow connection order

#### TCP Network (Cross-platform)

```
Host: 127.0.0.1 (configurable)
Port: Random available port
```

- Communicates via TCP socket
- Suitable for remote debugging scenarios

**Connection Order** (applies to all transport methods):
The debugger must create/listen to the channel before starting the debuggee program.

### 1.2 Message Format: `CommandInfo` Structure

Each message consists of a **fixed 20-byte header** + **variable data**, all fields in little-endian:

```
Offset  Size  Field       Description
------  ----  ----------  ------------------------------------------
0       4     Command     Command ID (see table below)
4       4     DataSize    Bytes of following Data (0 = no data)
8       4     Value1      Command parameter 1 (meaning depends on command)
12      4     Value2      Command parameter 2 (meaning depends on command)
16      4     Timestamp   Timestamp filled by debugger (can be ignored by program)
20      N     Data        Variable-length data (exists when DataSize > 0)
```

> **Protocol Version: 12**. Both parties exchange versions during handshake; mismatch results in error and disconnection.

### 1.3 Command Set

#### Debugger → Debuggee

| Command ID | Name | Value1 | Value2 | Data |
|-----------|------|--------|--------|------|
| 0 | **Stop** | — | — | — |
| 1 | **Step** | — | 0=Into / 1=Over / 2=Out | — |
| 2 | **Run** | — | — | — |
| 3 | **BreakPoint** | 1=Add / 2=Remove / 3=Clear | `(fileNum << 20) \| lineNum` | — |
| 4 | **ClearBreakPoints** | — | — | — |
| 9 | **GetGlobalNames** | — | — | — |
| 10 | **GetGlobals** | — | — | — |
| 11 | **GetLocals** | procedure index | — | — |
| 12 | **GetLocalNames** | procedure index | — | — |
| 16 | **GetHistory** (call stack) | — | — | — |
| 33 | **EvaluateExpression** | — | — | UTF-8 expression string |
| 37 | **Kill** (terminate program) | — | — | — |

#### Debuggee → Debugger

| Command ID | Name | Value1 | Value2 | Data |
|-----------|------|--------|--------|------|
| 4 | **Stopped** | fileNum | lineNum | — |
| 5 | **End** | exit code | — | — |
| 6 | **Error** (runtime error) | — | — | UTF-16LE error description |
| 7 | **DebugPrint** | — | — | UTF-16LE text |
| 8 | **CallDebugger** | fileNum | lineNum | — |
| 17 | **History** (stack frame data) | — | — | See below |
| 18 | **GlobalNames** | — | — | Name list (see below) |
| 19 | **Globals** | — | — | Variable value list |
| 20 | **LocalNames** | — | — | Name list |
| 21 | **Locals** | — | — | Variable value list |
| 34 | **ExpressionResult** | — | — | UTF-8 result string |

### 1.4 History (Call Stack) Data Format

The Data section of `History` messages contains consecutive frame records, each with the format:

```
[4B little-endian line number] [UTF-16LE procedure name \0]
```

The top frame (current execution location) is first.

### 1.5 Variable Name/Value List Format

`GlobalNames` / `LocalNames` data section:

```
[4B variable count N]
N × { [4B type ID] [UTF-16LE variable name \0] }
```

`Globals` / `Locals` data section:

```
N × { value parsed according to type ID }
```

| Type ID | PureBasic Type | Value Format |
|--------|---------------|--------|
| 1 | Byte | 1B signed |
| 2 | Word | 2B signed |
| 3 | Long | 4B signed |
| 4 | Float | 4B IEEE 754 |
| 5 | String | 4B length + UTF-16LE characters |
| 6 | Double | 8B IEEE 754 |
| 7 | Quad | 8B signed |
| 8 | Character | 2B |
| 9 | Pointer | 4B or 8B (depends on target architecture) |
| 10 | Integer | 4B or 8B (depends on target architecture) |

### 1.6 Compiler Interface

```bash
# Method 1: Direct compilation (recommended for debug launch)
pbcompiler.exe source.pb /DEBUGGER /EXE output.exe

# Method 2: Standby pipe mode (for long-term IDE reuse)
pbcompiler.exe --standby
```

When launching debug, the pipe must be connected after compilation completes and before starting the program.

---

## 2. Architecture Design

### Three-Process Model

```
┌─────────────────────────────────────────────────────────────────┐
│  VSCode Extension Host                                          │
│  src/extension.ts                                               │
│  ┌──────────────────────┐   DebugConfigurationProvider         │
│  │  LanguageClient (LSP)│   (Register debug type "purebasic")   │
│  └──────────────────────┘                                       │
└───────────────────────┬─────────────────────────────────────────┘
                        │  DAP (stdio)
                        │  JSON-RPC over stdin/stdout
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  Debug Adapter Process                                          │
│  out/debug/debugAdapter.js  (Independent Node.js process)       │
│                                                                  │
│  ┌──────────────┐   ┌────────────────┐   ┌───────────────────┐ │
│  │ DAPSession   │   │ Transport      │   │ CompilerLauncher  │ │
│  │ (vscode-dap) │◄──│ (Multiple impl)│   │ (Call pbcompiler) │ │
│  └──────────────┘   └───────┬────────┘   └───────────────────┘ │
│                             │ Pipe/FIFO/TCP                     │
└─────────────────────────────┼───────────────────────────────────┘
                              │  PipeA (commands) / PipeB (events)
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  PureBasic Debuggee (Target Process)                            │
│  Compiled by pbcompiler and started in /DEBUGGER mode           │
│  Gets connection info via PB_DEBUGGER_Communication env var     │
└─────────────────────────────────────────────────────────────────┘
```

### Transport Layer Abstraction

The debugger supports multiple transport methods through a unified interface:

| Transport | Implementation File | Platform | Status |
|----------|----------|----------|------|
| Named Pipe | `PipeTransport.ts` | Windows | Verified |
| FIFO | `FifoTransport.ts` | macOS/Linux | macOS Verified |
| TCP | `NetworkTransport.ts` | Cross-platform | Pending verification |
| Native | `NativeTransport.ts` | Windows | Pending verification |

### Data Flow Example

```
User sets breakpoint → VSCode UI
  → DAP setBreakpoints request → DAPSession
  → BreakPoint command (ID=3) → PipeA → PB Program

PB Program hits breakpoint → Stopped event (ID=4) → PipeB
  → PipeClient → DAPSession
  → DAP stopped event → VSCode UI (highlight current line)
```

---

## 3. File Structure

```
src/debug/
├── debugAdapter.ts          # Adapter entry: start DAPServer, listen on stdio
├── session/
│   ├── PBDebugSession.ts    # Core: extends DebugSession, implements all DAP handlers
│   └── sessionState.ts      # Session state machine (Idle / Running / Stopped / Terminated)
├── protocol/
│   ├── CommandInfo.ts       # CommandInfo structure serialization/deserialization
│   ├── commands.ts          # Command ID constant enums
│   └── variableParser.ts    # Parse variable name/value binary data
├── transport/
│   ├── PipeTransport.ts     # Windows named pipe implementation
│   ├── FifoTransport.ts     # Unix FIFO implementation (macOS/Linux)
│   ├── NetworkTransport.ts  # TCP network transport implementation
│   ├── NativeTransport.ts   # Windows Native API implementation
│   ├── TransportFactory.ts  # Transport factory, creates instance based on config
│   └── MessageBuffer.ts     # Frame splitting (by DataSize field)
├── compiler/
│   └── CompilerLauncher.ts  # Call pbcompiler, manage compilation and process launch
└── types/
    └── debugTypes.ts        # Debug-related TypeScript type definitions
```

### File Responsibilities

| File | Responsibility |
|------|------|
| `debugAdapter.ts` | Program entry, creates `PBDebugSession` instance, communicates with VSCode via stdio |
| `PBDebugSession.ts` | DAP protocol implementation core, translates DAP requests to PB commands and PB events to DAP events |
| `sessionState.ts` | Tracks debug session state, prevents sending commands in wrong state |
| `CommandInfo.ts` | `Buffer` serialization/deserialization of 20-byte header + Data |
| `commands.ts` | `PBCommand` / `PBEvent` enum constants |
| `variableParser.ts` | Parse `GlobalNames`/`Globals` binary data, generate `DebugProtocol.Variable[]` |
| `PipeTransport.ts` | Windows named pipe implementation using `net.createServer` |
| `FifoTransport.ts` | Unix FIFO implementation using `fs.mkfifo` and file streams |
| `NetworkTransport.ts` | TCP socket implementation |
| `TransportFactory.ts` | Creates corresponding transport instance based on `transport` config in `launch.json` |
| `MessageBuffer.ts` | Maintains receive buffer, splits complete frames by `DataSize` field |
| `CompilerLauncher.ts` | Generate connection ID, construct compile command line, start `pbcompiler`, wait for compilation |
| `debugTypes.ts` | Types like `PBVariable`, `PBStackFrame`, `LaunchConfig` |

---

## 4. Configuration Guide

### 4.1 Minimal Configuration Example

Create `.vscode/launch.json`:

```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "purebasic",
      "request": "launch",
      "name": "Debug PureBasic",
      "program": "${file}",
      "stopOnEntry": false
    }
  ]
}
```

Or launch directly with F5 shortcut (no configuration file needed).

### 4.2 Full Configuration Options

| Property | Type | Default | Description |
|------|------|--------|------|
| `program` | string | `${file}` | Path to PureBasic source file to debug |
| `compiler` | string | `pbcompiler` | Path to PureBasic compiler |
| `stopOnEntry` | boolean | `false` | Whether to pause at entry point on launch |
| `transport` | string | `auto` | Transport method: `auto`, `pipe`, `fifo`, `network`, `native` |
| `debugHost` | string | `127.0.0.1` | Host address for network mode |
| `communication` | string | Auto-generated | Force specify communication ID (advanced option) |
| `trace` | boolean | `false` | Enable detailed debug logging |

### 4.3 Transport Mode Selection

| Mode | Windows | Linux | macOS | Description |
|------|---------|-------|-------|------|
| `auto` | Named Pipe ✓ | FIFO¹ | FIFO ✓ | Automatically select best method for platform |
| `pipe` | Named Pipe | - | - | Windows named pipe |
| `fifo` | - | FIFO¹ | FIFO¹ | Unix FIFO |
| `network` | TCP | TCP | TCP | TCP socket |
| `native` | Native API | - | - | Windows Native API |

**Legend**: ✓ = Verified, ¹ = Expected to work (not verified), - = Not supported

### 4.4 `PB_DEBUGGER_Options` Environment Variable

The compiled program receives debug configuration via environment variable:

```
PB_DEBUGGER_Options: <unicode>;<callOnStart>;<callOnEnd>;<bigEndian>
```

- `unicode`: Always `1` (UTF-16LE encoding)
- `callOnStart`: `1` = pause on start (controlled by `stopOnEntry`)
- `callOnEnd`: Always `0`
- `bigEndian`: Always `0` (little-endian)

---

## 5. Key Implementation Points

### 5.1 Channel Connection Order (Critical)

```
Debugger Process                    Debuggee Process
---------------                     ----------------
1. Generate random PIPE_ID
2. CreateNamedPipe(PipeA)  ────►
3. CreateNamedPipe(PipeB)  ────►
4. Set env var PB_DEBUGGER_Communication=PIPE_ID
5. Start pbcompiler.exe compilation
6. Wait for compilation to complete
7. Launch debuggee (inherits env vars)
                                     8. Read env var to get PIPE_ID
8. ConnectNamedPipe(PipeA)           9. CreateFile(PipeA)  ◄────
9. ConnectNamedPipe(PipeB)           10. CreateFile(PipeB) ◄────
10. Handshake (exchange protocol version=12)
```

> **Trap**: If the program is started before creating the channel, it will crash on connection failure. The channel must be created first.

### 5.2 Frame Splitting

All transport methods (Named Pipe, FIFO, TCP) are stream-based and must be manually framed according to the `DataSize` field in the message header:

```typescript
// MessageBuffer.ts pseudocode
class MessageBuffer {
  private buffer: Buffer = Buffer.alloc(0);

  append(chunk: Buffer): CommandInfo[] {
    this.buffer = Buffer.concat([this.buffer, chunk]);
    const messages: CommandInfo[] = [];

    while (this.buffer.length >= 20) {  // At least full header
      const dataSize = this.buffer.readUInt32LE(4);
      const totalSize = 20 + dataSize;

      if (this.buffer.length < totalSize) break;  // Wait for more data

      messages.push(parseCommandInfo(this.buffer.slice(0, totalSize)));
      this.buffer = this.buffer.slice(totalSize);
    }

    return messages;
  }
}
```

### 5.3 Asynchronous Request-Response Matching

The PB protocol has no request ID; responses are distinguished by command type. A pending queue must be maintained:

```typescript
// Send request and wait for specific response type
async request(command: PBCommand, responseType: PBEvent, ...): Promise<CommandInfo> {
  return new Promise((resolve) => {
    this.pendingResponses.set(responseType, resolve);
    this.send(command, ...);
  });
}
```

> **Note**: `GetGlobalNames` and `GetGlobals` need to wait for their respective responses and cannot be sent concurrently (protocol does not support request IDs).

### 5.4 String Type Decoding

PureBasic Strings are transmitted in UTF-16LE encoding in the debug protocol:

```typescript
function decodeUTF16LEString(buf: Buffer, offset: number): string {
  // First read 4B length (character count, excluding terminator)
  const charCount = buf.readUInt32LE(offset);
  const start = offset + 4;
  const end = start + charCount * 2;
  return buf.slice(start, end).toString('utf16le');
}
```

### 5.5 File Number Mapping

The PB debug protocol uses `fileNum` (integer) to identify files, while DAP uses file paths (URI). A mapping table must be maintained:

```typescript
// Establish mapping during launchRequest
// fileNum=0 is always the main file (the compiled .pb file)
// IncludeFile fileNums appear in the first Stopped event
private fileNumToPath = new Map<number, string>();
```

---

## 6. Risks and Challenges

| Risk | Level | Mitigation |
|------|------|---------|
| **Pipe direction confirmation**: PipeA/PipeB input/output direction may be opposite from documentation | Medium | Confirm through actual testing after implementation, protocol handshake can verify direction |
| **Named pipe API**: Node.js on Windows uses `net.createServer('\\\\.\\pipe\\...')` instead of Win32 API | Medium | Use `net` module, server-side `createServer` + `listen`, client-side `createConnection` |
| **Race condition**: Debuggee may try to connect before debugger connects to channel | Medium | Must create/listen to channel before starting program (see 5.1) |
| **String type encoding**: Different PB versions may use different encodings (UTF-16LE vs ASCII) | Low | Distinguish by protocol version, implement UTF-16LE first |
| **64-bit vs 32-bit**: Integer/Pointer sizes differ | Low | Determine target architecture via `launch.json` config or compiler output |
| **Compiler path**: `pbcompiler.exe` may not be in PATH in user environment | Low | Provide `compiler` config in `launch.json` with friendly error messages |
| **Pipe buffer overflow**: Large number of local variables may exceed buffer in single response | Low | `MessageBuffer` dynamically expands with no fixed size limit |
| **Process leak**: Debuggee not terminated when debug session disconnects unexpectedly | Medium | Register `process.on('exit')` and VSCode `onDidTerminateDebugSession` events for cleanup |

### Platform Support

| Platform | Transport | Status |
|------|----------|------|
| Windows | Named Pipe | Verified |
| macOS | FIFO | Verified |
| Linux | FIFO | Expected to work (not verified) |

All platforms use the same PureBasic debug protocol, only the transport layer implementation differs.

---

## Appendix: References

- [fantaisie-software/purebasic](https://github.com/fantaisie-software/purebasic) — PureBasic official open-source IDE, contains complete debug protocol implementation
  - `PureBasicIDE/Debugger.pb` — Debugger main logic
  - `PureBasicIDE/DebuggerInterface.pb` — Debug protocol command/event definitions
- [Microsoft DAP Specification](https://microsoft.github.io/debug-adapter-protocol/specification) — Debug Adapter Protocol complete specification
- [@vscode/debugadapter](https://www.npmjs.com/package/@vscode/debugadapter) — VSCode official DAP Node.js SDK
- Reusable code in this project:
  - `src/server/utils/error-handler.ts` — `ErrorHandler` class
  - `src/types/generics.ts` — `Result<T,E>` and other generic utility types
  - `src/server/utils/fs-utils.ts` — File path utilities

